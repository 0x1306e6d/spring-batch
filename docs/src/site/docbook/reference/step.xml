<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
<chapter id="step">
  <title>Configuring a Step</title>

  <para>A <classname>Step</classname> is a domain object that encapsulates an
  independent, sequential phase of a batch job and contains all of the
  information necessary to define and control the actual batch processing.
  This is a necessarily vague description because the contents of any given
  <classname>Step</classname> are at the discretion of the developer writing a
  <classname>Job</classname>. A Step can be as simple or complex as the
  developer desires. A simple <classname>Step</classname> might load data from
  a file into the database, requiring little or no code. (depending upon the
  implementations used) A more complex <classname>Step</classname> may have
  complicated business rules that are applied as part of the
  processing.</para>

  <mediaobject>
    <imageobject role="html">
      <imagedata align="center" fileref="images/step.png" scale="75" width="" />
    </imageobject>

    <imageobject role="fo">
      <imagedata align="center" contentwidth="480"
                 fileref="src/site/docbook/reference/images/step.png"
                 scale="60" width="75%" />
    </imageobject>
  </mediaobject>

  <section>
    <title>Chunk-Oriented Processing</title>

    <para>Spring Batch uses a 'Chunk Oriented' processing style within it's
    most common implementation. Chunk oriented processing refers to reading
    the data one at a time, and creating 'chunks' that will be written out,
    within a transaction boundary. One item is read in from an
    <classname>ItemReader</classname>, handed to an
    <classname>ItemWriter</classname>, and aggregated. Once the number of
    items read equals the commit interval, the entire chunk is written out via
    the ItemWriter, and then the transaction is committed.</para>

    <mediaobject>
      <imageobject role="html">
        <imagedata align="center"
                   fileref="images/chunk-oriented-processing.png" scale="75"
                   width="" />
      </imageobject>

      <imageobject role="fo">
        <imagedata align="center"
                   fileref="src/site/docbook/reference/images/chunk-oriented-processing.png"
                   width="75%" />
      </imageobject>
    </mediaobject>

    <para>Below is a code representation of the same concepts shown
    above:</para>

    <programlisting>  
  List items = new Arraylist();
  for(int i = 0; i &lt; commitInterval; i++){
    Object processedItem = itemProcessor.process(itemReader.read());
    items.add(processedItem);
  }
  itemWriter.write(items);

</programlisting>

    <section>
      <title>Configuring a Step</title>

      <para>Despite the relatively short list of required dependencies for a
      <classname>Step</classname>, it is an extremely complex class that can
      potentially contain many collaborators. In order to ease configuration,
      the Spring Batch namespace can be used:</para>

      <programlisting>
  &lt;job id="sampleJob"&gt;
    &lt;step name="step1" job-repository="jobRepository" transaction-manager="transactionManager"&gt;
      &lt;tasklet reader="itemReader" writer="itemWriter" commit-interval="10"/&gt;
    &lt;/step&gt;
  &lt;/job&gt;

</programlisting>

      <para>The configuration above represents the only required dependencies
      to create a item-oriented step:<itemizedlist>
          <listitem>
            <para>reader - The <classname>ItemReader</classname> that provides
            items for processing.</para>
          </listitem>

          <listitem>
            <para>writer - The <classname>ItemWriter</classname> that
            processes the items provided by the
            <classname>ItemReader</classname>.</para>
          </listitem>

          <listitem>
            <para>transaction-manager - Spring's
            <classname>PlatformTransactionManager</classname> that will be
            used to begin and commit transactions during processing.</para>
          </listitem>

          <listitem>
            <para>job-repository - The <classname>JobRepository</classname>
            that will be used to periodically store the
            <classname>StepExecution</classname> and
            <classname>ExecutionContext</classname> during processing (just
            before committing).</para>
          </listitem>

          <listitem>
            <para>commit-interval - The number of items that will be processed
            before the transaction is committed.</para>
          </listitem>
        </itemizedlist></para>

      <para>It should be noted that, job-repository defaults to
      "jobRepository" and transaction-manager defaults to "transactionManger".
      Furthermore, the ItemProcessor is not required, since the item could be
      directly passed from the reader to the writer.</para>
    </section>

    <section>
      <title>The Commit Interval</title>

      <para>As mentioned above, a step reads in and writes out items,
      periodically committing using the supplied
      <classname>PlatformTransactionManager</classname>. With a
      commit-interval of 1, it will commit after writing only one item. This
      is less than ideal in many situations, since beginning and committing a
      transaction is expensive. Ideally, it is preferable to process as many
      items as possible in each transaction, which is completely dependent
      upon the type of data being processed and the resources with which the
      step is interacting. For this reason, the number of items that are
      processed within a commit can be configured.</para>

      <programlisting>
  &lt;job id="sampleJob"&gt;
    &lt;step name="step1" job-repository="jobRepository" transaction-manager="transactionManager"&gt;
      &lt;tasklet reader="itemReader" writer="itemWriter" <emphasis
          role="bold">commit-interval="10"</emphasis>/&gt;
    &lt;/step&gt;
  &lt;/job&gt;

</programlisting>

      <para>In the example above, 10 items will be processed within each
      transaction. At the beginning of processing a transaction is begun, and
      each time <markup>read</markup> is called on the
      <classname>ItemReader</classname>, a counter is incremented. When it
      reaches 10, the list of aggregated items is passed to the
      <classname>ItemWriter</classname>, and the transaction will be
      committed.</para>
    </section>

    <section>
      <title>Configuring a Step for Restart</title>

      <para>In the Chapter on configuring a Job, restarting a
      <classname>Job</classname> was discussed. Restart has numerous impacts
      on steps, and as such may require some specific configuration.</para>

      <section>
        <title>Setting a StartLimit</title>

        <para>There are many scenarios where you may want to control the
        number of times a <classname>Step</classname> may be started. An
        example is a <classname>Step</classname> that may be run only once,
        usually because it invalidates some resource that must be fixed
        manually before it can be run again. This is configurable on the step
        level, since different steps have different requirements. One Step
        that may only be executed once can exist as part of the same
        <classname>Job</classname> as <classname>Step</classname> that can be
        run infinitely. Below is an example start limit configuration:</para>

        <programlisting> 
  &lt;step name="step1"&gt;
    &lt;tasklet reader="itemReader" writer="itemWriter" commit-interval="10" <emphasis
            role="bold">start-limit="1"</emphasis>/&gt;
  &lt;/step&gt;

</programlisting>

        <para>The simple step above can be run only once. Attempting to run it
        again will cause an exception to be thrown. It should be noted that
        the default value for the start-limit is
        <classname>Integer.MAX_VALUE</classname>.</para>
      </section>

      <section>
        <title>Restarting a completed step</title>

        <para>In the case of a restartable job, there may be one or more steps
        that should always be run, regardless of whether or not they were
        successful the first time. An example might be a validation step, or a
        <classname>Step</classname> that cleans up resources before
        processing. During normal processing of a restarted job, any step with
        a status of 'COMPLETED', meaning it has already been completed
        successfully, will be skipped. Setting allow-start-if-complete to
        "true" overrides this so that the step will always run:</para>

        <programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="itemReader" writer="itemWriter" commit-interval="10" <emphasis
            role="bold">allow-start-if-complete="true"</emphasis>/&gt;
  &lt;/step&gt;

</programlisting>
      </section>

      <section>
        <title>Step restart configuration example</title>

        <programlisting>
  &lt;job id="footballJob" restartable="true"&gt;
    &lt;step name="playerload" next="gameLoad"&gt;
      &lt;tasklet reader="playerFileItemReader" writer="playerWriter" 
               commit-interval="10" /&gt;
    &lt;/step&gt;
    &lt;step name="gameLoad" next="playerSummarization"&gt;
      &lt;tasklet reader="gameFileItemReader" writer="gameWriter" 
               commit-interval="10" allow-start-if-complete="true"/&gt;
    &lt;/step&gt;
    &lt;step name="playerSummarization"&gt;
      &lt;tasklet reader="playerSummarizationSource" writer="summaryWriter" 
               commit-interval="10" start-limit="3"/&gt;
    &lt;/step&gt;
  &lt;/job&gt;

</programlisting>

        <para>The above example configuration is for a job that loads in
        information about football games and summarizes them. It contains
        three steps: playerLoad, gameLoad, and playerSummarization. The
        playerLoad <classname>Step</classname> loads player information from a
        flat file, while the gameLoad <classname>Step</classname> does the
        same for games. The final <classname>Step</classname>,
        playerSummarization, then summarizes the statistics for each player
        based upon the provided games. It is assumed that the file loaded by
        'playerLoad' must be loaded only once, but that 'gameLoad' will load
        any games found within a particular directory, deleting them after
        they have been successfully loaded into the database. As a result, the
        playerLoad <classname>Step</classname> contains no additional
        configuration. It can be started almost limitlessly, and if complete
        will be skipped. The 'gameLoad' <classname>Step</classname>, however,
        needs to be run every time in case extra files have been dropped since
        it last executed. It has 'allow-start-if-complete' set to 'true' in
        order to always be started. (It is assumed that the database tables
        games are loaded into has a process indicator on it, to ensure new
        games can be properly found by the summarization step). The
        summarization <classname>Step</classname>, which is the most important
        in the <classname>Job</classname>, is configured to have a start limit
        of 3. This is useful because if the step continually fails, a new exit
        code will be returned to the operators that control job execution, and
        it won't be allowed to start again until manual intervention has taken
        place.</para>

        <note>
          <para>This job is purely for example purposes and is not the same as
          the footballJob found in the samples project.</para>
        </note>

        <para>Run 1:</para>

        <orderedlist>
          <listitem>
            <para>playerLoad is executed and completes successfully, adding
            400 players to the 'PLAYERS' table.</para>
          </listitem>

          <listitem>
            <para>gameLoad is executed and processes 11 files worth of game
            data, loading their contents into the 'GAMES' table.</para>
          </listitem>

          <listitem>
            <para>playerSummarization begins processing and fails after 5
            minutes.</para>
          </listitem>
        </orderedlist>

        <para>Run 2:</para>

        <orderedlist>
          <listitem>
            <para>playerLoad is not run, since it has already completed
            successfully, and allow-start-if-complete is 'false' (the
            default).</para>
          </listitem>

          <listitem>
            <para>gameLoad is executed again and processes another 2 files,
            loading their contents into the 'GAMES' table as well (with a
            process indicator indicating they have yet to be processed)</para>
          </listitem>

          <listitem>
            <para>playerSummarization begins processing of all remaining game
            data (filtering using the process indicator) and fails again after
            30 minutes.</para>
          </listitem>
        </orderedlist>

        <para>Run 3:</para>

        <orderedlist>
          <listitem>
            <para>playerLoad is not run, since it has already completed
            successfully, and allow-start-if-complete is 'false' (the
            default).</para>
          </listitem>

          <listitem>
            <para>gameLoad is executed again and processes another 2 files,
            loading their contents into the 'GAMES' table as well (with a
            process indicator indicating they have yet to be processed)</para>
          </listitem>

          <listitem>
            <para>playerSummarization is not start, and the job is immediately
            killed, since this is the third execution of playerSummarization,
            and it's limit is only 2. The limit must either be raised, or the
            <classname>Job</classname> must be executed as a new
            <classname>JobInstance</classname>.</para>
          </listitem>
        </orderedlist>
      </section>
    </section>

    <section>
      <title>Configuring Skip Logic</title>

      <para>There are many scenarios where errors encountered while processing
      should not result in <classname>Step</classname> failure, but should be
      skipped instead. This is usually a decision that must be made by someone
      who understands the data itself and what meaning it has. Financial data,
      for example, may not be skippable because it results in money being
      transferred, which needs to be completely accurate. Loading a list of
      vendors, on the other hand, might allow for skips. If a vendor is not
      loaded because it was formatted incorrectly or was missing necessary
      information, then there probably won't be issues. Usually these bad
      records are logged as well, which will be covered later when discussing
      listeners.<programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="flatFileItemReader" writer="itemWriter" commit-interval="10" <emphasis
            role="bold">skip-limit="10"</emphasis>&gt;
      <emphasis role="bold">&lt;skippable-exception-classes&gt;
        org.springframework.batch.item.file.FlatFileParseException
      &lt;/skippable-exception-classes&gt;</emphasis>
    &lt;/tasklet&gt;
  &lt;/step&gt;

</programlisting></para>

      <para>In this example, a <classname>FlatFileItemReader</classname> is
      used, and if at any point a
      <classname>FlatFileParseException</classname> is thrown, it will be
      skipped and counted against the total skip limit of 10. It should be
      noted that any failures encountered while reading will not count against
      the commit interval. In other words, the commit interval is only
      incremented on writes (regardless of success or failure).</para>
    </section>

    <section>
      <para>One problem with the example above is that any other exception
      besides a <classname>FlatFileParseException</classname> will cause the
      <classname>Job</classname> to fail. In certain scenarios this may be the
      correct behaviour, however, in certain scenarios it may be easier to
      identify which exceptions should cause failure and skip everything
      else:<programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="flatFileItemReader" writer="itemWriter" commit-interval="10" <emphasis
            role="bold">skip-limit="10"</emphasis>&gt;
<emphasis role="bold">      &lt;skippable-exception-classes&gt;
        java.lang.Exception
      &lt;/skippable-exception-classes&gt;
      &lt;fatal-exception-classes&gt;
        java.io.FileNotFoundException
      &lt;/fatal-exception-classes&gt;
</emphasis>    &lt;/tasklet&gt;
  &lt;/step&gt;

</programlisting></para>

      <para>By setting the skippable exceptions to
      <classname>java.lang.Exception</classname>, any exception that is thrown
      will be skipped. However, the second list, 'fatal-exception-classes',
      contains specific exceptions that should be fatal if encountered.</para>
    </section>

    <section>
      <title>Configuring Retry Logic</title>

      <para>In most cases you want an exception to cause either a skip or
      <classname>Step</classname> failure. However, not all exceptions are
      deterministic. If a <classname>FlatFileParseException</classname> is
      encountered while reading, it will always be thrown for that record.
      Resetting the <classname>ItemReader</classname> will not help. However,
      for other exceptions, such as a
      <classname>DeadlockLoserDataAccessException</classname>, which indicates
      that the current process has attempted to update a record that another
      process holds a lock on, waiting and trying again might result in
      success. In this case, retry should be configured:</para>

      <programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="itemReader" writer="itemWriter" commit-interval="2" <emphasis
          role="bold">retry-limit="3"</emphasis>&gt;
      <emphasis role="bold">&lt;retryable-exception-classes&gt;
        org.springframework.dao.DeadlockLoserDataAccessException
      &lt;/retryable-exception-classes&gt;</emphasis>
    &lt;/tasklet&gt;
  &lt;/step&gt;

</programlisting>

      <para>The <classname>Step</classname> allows a limit for the number of
      times an individual item can be retried, and a list of exceptions that
      are 'retryable'.</para>
    </section>

    <section>
      <title>Controlling rollback</title>

      <para>By default, regardless of retry or skip, any exceptions thrown
      from the <classname>ItemWriter</classname> will cause the transaction
      controlled by the <classname>Step</classname> to rollback. If skip is
      configured as described above, exceptions thrown from the
      <classname>ItemReader</classname> will not cause a rollback. However,
      there are many scenarios in which exceptions thrown from the
      <classname>ItemWriter</classname> should not cause a rollback because no
      action has taken place to invalidate the transaction. For this reason,
      the <classname>Step</classname> can be configured with a list of
      exceptions that should not cause rollback. The transaction-attribute
      attribute is a comma-separated list. Prefixing a class name with the "+"
      symbol will indicate that exception should not cause rollback.</para>

      <programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="itemReader" writer="itemWriter" commit-interval="2" skip-limit="1"
             <emphasis role="bold">transaction-attribute="+org.springframework.batch.item.validator.ValidationException"</emphasis>&gt;
    &lt;/tasklet&gt;
  &lt;/step&gt;

</programlisting>

      <para>Transaction attributes can be used to control multiple other
      settings such as isolation and propagation behaviour. More information
      on setting transaction attributes can be found in the spring core
      documentation.</para>
    </section>

    <section>
      <title>Registering ItemStreams with the Step</title>

      <para>The step has to take care of <classname>ItemStream</classname>
      callbacks at the necessary points in its lifecycle. (for more
      information on the ItemStream interface, please refer to the chapter on
      Readers and Writers) This is vital if a step fails, and might need to be
      restarted, because the <classname>ItemStream</classname> interface is
      where the step gets the information it needs about persistent state
      between executions.</para>

      <para>If the <classname>ItemReader</classname>,
      <classname>ItemProcessor</classname>, or
      <classname>ItemWriter</classname> itself implements the
      <classname>ItemStream</classname> interface, then these will be
      registered automatically. Any other streams need to be registered
      separately. This is often the case where there are indirect
      dependencies, like delegates being injected into the reader and writer.
      To a stream it can be injected into the <classname>Step</classname>
      through the 'streams' element, as illustrated below:</para>

      <programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="itemReader" writer="compositeWriter" commit-interval="2"&gt;
      <emphasis role="bold">&lt;streams&gt;
        &lt;stream ref="fileItemWriter1"/&gt;
        &lt;stream ref="fileItemWriter2"/&gt;
      &lt;/streams&gt;</emphasis>
    &lt;/tasklet&gt;
  &lt;/step&gt;

  &lt;beans:bean id="compositeWriter" class="org.springframework.batch.item.support.CompositeItemWriter"&gt;
    &lt;beans:property name="delegates"&gt;
      &lt;beans:list&gt;
        &lt;beans:ref bean="fileItemWriter1" /&gt;
        &lt;beans:ref bean="fileItemWriter2" /&gt;
      &lt;/beans:list&gt;
    &lt;/beans:property&gt;
  &lt;/beans:bean&gt;

</programlisting>

      <para>In the example above, the
      <classname>CompositeItemWriter</classname> is not an
      <classname>ItemStream</classname>, but both of its delegates are.
      Therefore, both delegate writers must be explicitly registered as
      streams in order for the framework to handle them correctly. The
      <classname>ItemReader</classname> does not need to explicitly registered
      as a stream because it is a direct property of the
      <classname>Step</classname>. The step will now be restartable and the
      state of the reader and writer will be correctly persisted in case of a
      failure.</para>
    </section>

    <section>
      <title>Intercepting Step Execution</title>

      <para>Just as with the <classname>Job</classname>, there are many events
      during the execution of a <classname>Step</classname> where a user may
      need to perform some functionality. For example, in order to write out
      to a flat file that requires a footer, the
      <classname>ItemWriter</classname> needs to be notified when the
      <classname>Step</classname> has been completed, so that the footer can
      written. This can be accomplished with one of many
      <classname>Step</classname> scoped listeners.</para>

      <para>Any class that implements the <classname>StepListener</classname>
      interface (or an extension thereof) can be applied to a step via the
      listeners element:</para>

      <programlisting>
  &lt;step name="step1"&gt;
    &lt;tasklet reader="reader" writer="writer" commit-interval="10"/&gt;
      &lt;listeners&gt;
        &lt;listener ref="stepListener"/&gt;
      &lt;/listeners&gt;
  &lt;/step&gt;

</programlisting>

      <para>In addition to the <classname>StepListener</classname> interfaces,
      annotations are provided address the same concerns.</para>

      <section>
        <title>StepExecutionListener</title>

        <para><classname>StepExecutionListener</classname> represents the most
        generic listener for <classname>Step</classname> execution. It allows
        for notification before a <classname>Step</classname> is started and
        after it has ends, whether it ended normally or failed:</para>

        <programlisting>
  public interface StepExecutionListener extends StepListener {

    void beforeStep(StepExecution stepExecution);

    ExitStatus afterStep(StepExecution stepExecution);
  }

</programlisting>

        <para><classname>ExitStatus</classname> is the return type of
        <methodname>afterStep</methodname> in order to allow listeners the
        chance to modify the exit code that is returned upon completion of a
        <classname>Step</classname>.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@BeforeStep</classname></para>
          </listitem>

          <listitem>
            <para><classname>@AfterStep</classname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>ChunkListener</title>

        <para>A chunk is defined as the items processed within the scope of a
        transaction. Committing a transaction, at each commit interval,
        commits a 'chunk'. A <classname>ChunkListener</classname> may be
        useful to perform logic before a chunk begins processing or after a
        chunk has completed:</para>

        <programlisting>  public interface ChunkListener extends StepListener {

    void beforeChunk();

    void afterChunk();
  }</programlisting>

        <para>The <methodname>beforeChunk</methodname> method is called after
        the transaction is started, but before <methodname>read</methodname>
        is called on the <classname>ItemReader</classname>. Conversely,
        <methodname>afterChunk</methodname> is called after the last call to
        <methodname>write</methodname> on the
        <classname>ItemWriter</classname>, but before the chunk has been
        committed.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@BeforeChunk</classname></para>
          </listitem>

          <listitem>
            <para><classname>@AfterChunk</classname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>ItemReadListener</title>

        <para>When discussing skip logic above, it was mentioned that it may
        be beneficial to log out skipped records, so that they can be deal
        with later. In the case of read errors, this can be done with an
        <classname>ItemReaderListener:</classname><programlisting>  public interface ItemReadListener&lt;T&gt; extends StepListener {
  
    void beforeRead();

    void afterRead(T item);
    
    void onReadError(Exception ex);
}</programlisting></para>

        <para>The <methodname>beforeRead</methodname> method will be called
        before each call to <methodname>read</methodname> on the
        <classname>ItemReader</classname>. The
        <methodname>afterRead</methodname> method will be called after each
        successful call to <methodname>read</methodname>, and will be passed
        the item that was read. If there was an error while reading, the
        <classname>onReadError</classname> method will be called. The
        exception encountered will be provided so that it can be
        logged.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@BeforeRead</classname></para>
          </listitem>

          <listitem>
            <para><classname>@AfterRead</classname></para>
          </listitem>

          <listitem>
            <para><classname>@OnReadError</classname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>ItemProcessListener</title>

        <para>Just as with the <classname>ItemReadListener</classname>, the
        processing of an item can be 'listened' to:</para>

        <programlisting>  public interface ItemProcessListener&lt;T, S&gt; extends StepListener {

    void beforeProcess(T item);

    void afterProcess(T item, S result);

    void onProcessError(T item, Exception e);
}</programlisting>

        <para>The <methodname>beforeProcess</methodname> method will be called
        before <methodname>process</methodname> on the
        <classname>ItemProcessor</classname>, and is handed the item that will
        be processed. The <methodname>afterProcess</methodname> method will be
        called after the item has been successfully processed. If there was an
        error while processing, the <methodname>onProcessError</methodname>
        method will be called. The exception encountered and the item that was
        attempted to be processed will be provided, so that they can be
        logged.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@BeforeProcess</classname></para>
          </listitem>

          <listitem>
            <para><classname>@AfterProcess</classname></para>
          </listitem>

          <listitem>
            <para><classname>@OnProcessError</classname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>ItemWriteListener</title>

        <para>The writing of an item can be 'listened' to with the
        <classname>ItemWriteListener</classname>:</para>

        <programlisting>  public interface ItemWriteListener&lt;S&gt; extends StepListener {

    void beforeWrite(List&lt;? extends S&gt; items);

    void afterWrite(List&lt;? extends S&gt; items);

    void onWriteError(Exception exception, List&lt;? extends S&gt; items);
}</programlisting>

        <para>The <methodname>beforeWrite</methodname> method will be called
        before <methodname>write</methodname> on the
        <classname>ItemWriter</classname>, and is handed the item that will be
        written. The <methodname>afterWrite</methodname> method will be called
        after the item has been successfully written. If there was an error
        while writing, the <methodname>onWriteError</methodname> method will
        be called. The exception encountered and the item that was attempted
        to be written will be provided, so that they can be logged.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@BeforeWrite</classname></para>
          </listitem>

          <listitem>
            <para><classname>@AfterWrite</classname></para>
          </listitem>

          <listitem>
            <para><classname>@OnWriteError</classname></para>
          </listitem>
        </itemizedlist>
      </section>

      <section>
        <title>SkipListener</title>

        <para>Both <classname>ItemReadListener</classname> and
        <classname>ItemWriteListner</classname> provide a mechanism for being
        notified of errors, but neither one will inform you that a record has
        actually been skipped. <methodname>onWriteError</methodname>, for
        example, will be called even if an item is retried and successful. For
        this reason, there is a separate interface for tracking skipped
        items:</para>

        <programlisting>
  public interface SkipListener&lt;T,S&gt; extends StepListener {

    void onSkipInRead(Throwable t);

    void onSkipInWrite(S item, Throwable t);

    void onSkipInProcess(T item, Throwable t);
  }

</programlisting>

        <para><methodname>onSkipInRead</methodname> will be called whenever an
        item is skipped while reading. It should be noted that rollbacks may
        cause the same item to be registered as skipped more than once.
        <methodname>onSkipInWrite</methodname> will be called when an item is
        skipped while writing. Because the item has been read successfully
        (and not skipped), it is also provided the item itself as an
        argument.</para>

        <para>The annotations corresponding to this interface are:</para>

        <itemizedlist>
          <listitem>
            <para><classname>@OnSkipInRead</classname></para>
          </listitem>

          <listitem>
            <para><classname>@OnSkipInWrite</classname></para>
          </listitem>

          <listitem>
            <para><classname>@OnSkipInProcess</classname></para>
          </listitem>
        </itemizedlist>

        <section>
          <title>SkipListeners and Transactions</title>

          <para>One of the most common use cases for a
          <classname>SkipListener</classname> is to log out a skipped item, so
          that another batch process or even human process can be used to
          evaluate and fix the issue leading to the skip. Because there are
          many cases in which the original trasaction may be rolledback,
          Spring Batch makes two garantees:</para>

          <orderedlist>
            <listitem>
              <para>The appropriate skip method (depending on when the error
              happened) will only be called once per item.</para>
            </listitem>

            <listitem>
              <para>The <classname>SkipListener</classname> will always be
              called just before the transaction is committed. This is to
              ensure that any transactional resources call by the listener are
              not rolled back by a failure within the
              <classname>ItemWriter</classname>.</para>
            </listitem>
          </orderedlist>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>TaskletStep</title>

    <para>Chunk oriented processing is not the only way to process in a
    <classname>Step</classname>. What if a <classname>Step</classname> must
    consist as a simple stored procedure call? You could implement the call as
    an <classname>ItemReader</classname> and return null after the procedure
    finishes, but it is a bit unnatural since there would need to be a no-op
    <classname>ItemWriter</classname> and lots of overhead for transaction
    handling, listeners, etc. Spring Batch provides an implementation of
    <classname>Step</classname> for this scenario:
    <classname>TaskletStep</classname>. As explained in Chapter 2, the
    <classname>Tasklet</classname> is a simple interface that has one method,
    <methodname>execute</methodname>, which will be a called once for the
    whole <classname>Step</classname>. <classname> Tasklet</classname>
    implementors might call a stored procedure, a script, or a simple SQL
    update statement. To create a <classname>TaskletStep</classname>, the
    'tasklet' attribute should reference a bean defining a
    <classname>Tasklet</classname> object; no 'tasklet' element is needed
    within the 'step':</para>

    <programlisting>
  &lt;step name="step1" <emphasis role="bold">tasklet="myTasklet"</emphasis> /&gt;

</programlisting>

    <note>
      <para>TaskletStep will automatically register the tasklet as
      <classname>StepExecutionListener</classname> if it implements this
      interface</para>
    </note>

    <section>
      <title>TaskletAdapter</title>

      <para>As with other adapters for the <classname>ItemWriter</classname>
      and <classname>ItemReader</classname> interfaces, the
      <classname>Tasklet</classname> interface contains an implementation that
      allows for adapting itself to any pre-existing class:
      <classname>TaskletAdapter</classname>. An example where this may be
      useful is an existing DAO that is used to update a flag on a set of
      records. The <classname>TaskletAdapter</classname> can be used to call
      this class without having to write an adapter for the
      <classname>Tasklet</classname> interface:</para>

      <programlisting>
  &lt;bean id="myTasklet" class="org.springframework.batch.core.step.tasklet.TaskletAdapter"&gt;
    &lt;property name="targetObject"&gt;
      &lt;bean class="org.mycompany.FooDao"&gt;
    &lt;/property&gt;
    &lt;property name="targetMethod" value-"updateFoo" /&gt;
  &lt;/bean&gt;

</programlisting>
    </section>

    <section>
      <title>Example Tasklet implementation</title>

      <para>Many batch jobs contain steps that must be done before the main
      processing begins in order to set up various resources, or after
      processing has completed to cleanup those resources. In the case of a
      job that works heavily with files, it is often necessary to delete
      certain files locally after they have been uploaded successfully to
      another location. The example below taken from the Spring Batch samples
      project, is a <classname>Tasklet</classname> implementation with just
      such a responsibility:</para>

      <programlisting>  public class FileDeletingTasklet implements Tasklet, InitializingBean {

    private Resource directory;

    public ExitStatus execute() throws Exception {
      File dir = directory.getFile();
      Assert.state(dir.isDirectory());
    
      File[] files = dir.listFiles();
      for (int i = 0; i &lt; files.length; i++) {
        boolean deleted = files[i].delete();
        if (!deleted) {
          throw new UnexpectedJobExecutionException("Could not delete file " + files[i].getPath());
        }
      }
      return ExitStatus.FINISHED;
    }

    public void setDirectoryResource(Resource directory) {
      this.directory = directory;
    }

    public void afterPropertiesSet() throws Exception {
      Assert.notNull(directory, "directory must be set");
    }
  }</programlisting>

      <para>The above <classname>Tasklet</classname> implementation will
      delete all files within a given directory. It should be noted that the
      <methodname>execute</methodname> method will only be called once. All
      that is left is to reference the <classname>Tasklet</classname> from the
      <classname>Step</classname>:</para>

      <programlisting>
  &lt;job id="taskletJob"&gt;
    &lt;step name="deleteFilesInDir" tasklet="fileDeletingTasklet"/&gt;
  &lt;/job&gt;

  &lt;bean id="fileDeletingTasklet" 
        class="org.springframework.batch.sample.tasklet.FileDeletingTasklet"&gt;
    &lt;property name="directoryResource"&gt;
      &lt;bean id="directory" 
            class="org.springframework.core.io.FileSystemResource"&gt;
        &lt;constructor-arg value="target/test-outputs/test-dir" /&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

</programlisting>
    </section>

    <section>
      <title>Executing System Commands</title>

      <para>Many batch jobs may require that an external command be called
      from within the batch job. Such a process could be kicked off separately
      by the scheduler, but the advantage of common meta-data about the run
      would be lost. Furthermore, a multi-step job would also need to be split
      up into multiple jobs as well. Because the need is so common, Spring
      Batch provides a <classname>Tasklet</classname> implementation for
      calling system commands:</para>

      <programlisting>
  &lt;bean class="org.springframework.batch.sample.tasklet.SystemCommandTasklet"&gt;
    &lt;property name="command" value="echo hello" /&gt;
    &lt;!-- 5 second timeout for the command to complete --&gt;
    &lt;property name="timeout" value="5000" /&gt;
  &lt;/bean&gt;

</programlisting>
    </section>
  </section>

  <section>
    <title>Controlling Step Flow</title>

    <para>With the ability to group steps together within an owning job, comes
    the need to be able to control how the job 'flows' from one step to
    another. The failure of a <classname>Step</classname> doesn't necessarily
    mean that the <classname>Job</classname> should fail. Further, there may
    be more than one type of 'success', which determines which
    <classname>Step</classname> should be executed next. Depending upon how a
    group of Steps is configured, certain steps may not even be processed at
    all.</para>

    <section>
      <title>Sequential Flow</title>

      <para>The simplest flow scenario is a job where all of the steps execute
      sequentially:</para>

      <mediaobject>
        <imageobject role="html">
          <imagedata align="center" fileref="images/sequential-flow.png"
                     scale="50" width="" />
        </imageobject>

        <imageobject role="fo">
          <imagedata align="center"
                     fileref="src/site/docbook/reference/images/sequential-flow.png"
                     width="75%" />
        </imageobject>
      </mediaobject>

      <para>This can be achieved using the 'next' attribute of
      <classname>Step</classname>:</para>

      <para><programlisting>
  &lt;job id="job"&gt;
    &lt;step name="stepA" next="stepB" /&gt;
    &lt;step name="stepB" next="stepC"/&gt;
    &lt;step name="stepC" /&gt;
  &lt;/job&gt;

</programlisting>In the scenario above, 'step A' will execute first. If 'step
      A' completes normally, then 'step B' will execute and so on. However, if
      'step A' fails, then the entire <classname>Job</classname> will fail and
      'step B' will not execute.</para>
    </section>

    <section>
      <title>Conditional Flow</title>

      <para>In the example above, there's only two possibilities:</para>

      <orderedlist>
        <listitem>
          <para>The Step is successful and the next Step should be
          executed</para>
        </listitem>

        <listitem>
          <para>The Step failed and thus the Job should fail.</para>
        </listitem>
      </orderedlist>

      <para>In many cases this may be sufficient. However, what about a
      scenario in which the failure of a Step should trigger a different Step,
      rather than causing failure? <mediaobject>
          <imageobject role="html">
            <imagedata align="center" fileref="images/conditional-flow.png"
                       scale="75" width="" />
          </imageobject>

          <imageobject role="fo">
            <imagedata align="center"
                       fileref="src/site/docbook/reference/images/conditional-flow.png"
                       width="75%" />
          </imageobject>
        </mediaobject></para>

      <para>In order to handle this scenario, the next step can be determined
      based on the result of the step by adding a next element to the Step.
      The "on" attribute uses a simple pattern-matching scheme to match the
      exit code of the Step to the various next elements declared. Only two
      special characters are allowed:</para>

      <itemizedlist>
        <listitem>
          <para>"*" will zero or more characters</para>
        </listitem>

        <listitem>
          <para>"?" will match exactly one character</para>
        </listitem>
      </itemizedlist>

      <para>For example, "c*t" will match "cat" and "count", while "c?t" will
      match "cat" but not "count".</para>

      <para>Any number of "next" elements is allowed, but if the step has an
      exit code that is not covered by a "next" element, then the framework
      will throw an exception and the job will fail. It is important to note
      that the framework will automatically order transitions from most
      specific to least specific. So even if the "next" elements were swapped
      for "stepA" below, an exit status of "FAILED" would still go to
      "stepB".</para>

      <para><programlisting>
  &lt;job id="job"&gt;
    &lt;step name="stepA"&gt;
      &lt;next on="FAILED" to="stepB" /&gt;
      &lt;next on="*" to="stepC" /&gt;
    &lt;/step&gt;
    &lt;step name="stepB" next="stepC" /&gt;
    &lt;step name="stepC" /&gt;
  &lt;/job&gt;

</programlisting></para>

      <section>
        <title>Batch Status vs. Exit Status</title>

        <para>When configuring a <classname>Job</classname> for conditional
        flow, it is important to understand the difference between
        <classname>BatchStatus</classname> and
        <classname>ExitStatus</classname>. <classname>BatchStatus</classname>
        is an enumeration that is a property of both
        <classname>JobExecution</classname> and
        <classname>StepExecution</classname>, and is used by the framework to
        record the status of a <classname>Job</classname> or
        <classname>Step</classname>. It can be one of the following values:
        COMPLETED, STARTING, STARTED, FAILED, STOPPING, STOPPED, or UNKNOWN.
        Most of them are self explanatory, COMPLETED is the status set when a
        step or job has completed successfully, FAILED is set when it fails,
        and so on. The example above contains the following 'next'
        element:</para>

        <programlisting>  
  &lt;next on="FAILED" to="stepB" /&gt;

</programlisting>

        <para>At first glance, it would appear that the 'on' attribute
        references the <classname>BatchStatus</classname> of the
        <classname>Step</classname> it belongs to. However, it references the
        <classname>ExitStatus</classname> of the <classname>Step</classname>.
        As the name implies, <classname>ExitStatus</classname> represents the
        status of a <classname>Step</classname> after it finishes execution.
        More specifically, the 'next' element above references the
        <classname>ExitCode</classname> of the
        <classname>ExitStatus</classname>. To write it in English, it says:
        "go to stepB if the exit code is FAILED". By default, the exit code is
        always the same as the <classname>BatchStatus</classname> for the
        Step, which is why the entry above works. However, what if the exit
        code needs to be different? A good example comes from the skip sample
        job, within the samples project:</para>

        <programlisting>  
  &lt;step name="step1"&gt;
    &lt;end on="FAILED" /&gt;
    &lt;next on="COMPLETED WITH SKIPS" to="errorPrint1" /&gt;
    &lt;next on="*" to="step2" /&gt;
  &lt;/step&gt;

</programlisting>

        <para>The above step has three possibilities:</para>

        <orderedlist>
          <listitem>
            <para>The step failed, in which case the job should fail.</para>
          </listitem>

          <listitem>
            <para>The Step completed successfully.</para>
          </listitem>

          <listitem>
            <para>The Step completed successfully, but with an exit code of
            'COMPLETED WITH SKIPS'. In this case, a different step should be
            run to handle the errors.</para>
          </listitem>
        </orderedlist>

        <para>The above configuration will work, however, something needs to
        change the exit code based on the condition of the execution having
        skipped records:</para>

        <programlisting>public class SkipCheckingListener implements StepExecutionListener {

  public ExitStatus afterStep(StepExecution stepExecution) {
    if (!stepExecution.getExitStatus().getExitCode().equals(ExitStatus.FAILED.getExitCode())
          &amp;&amp; stepExecution.getSkipCount() &gt; 0) {
      return new ExitStatus("COMPLETED WITH SKIPS");
    } else {
      return null;
    }
  }

  ...
}</programlisting>

        <para>The above code is a <classname>StepExecutionListener</classname>
        that first checks to make sure the <classname>Step</classname> was
        successful, and next if the skip count on the
        <classname>StepExecution</classname> is higher than 0. If both
        conditions are met, a new ExitStatus with an exit code of "COMPLETED
        WITH SKIPS" is returned.</para>
      </section>
    </section>

    <section>
      <title>Configuring for Stop</title>

      <para>If it is desired that the batch job stop under certain conditions,
      then either the "stop" tag or the "end" tag may be used.</para>

      <para>The "stop" tag indicates the job should stop processing with an
      exit status of "STOPPED". The "to" attribute tells the framework which
      step should be first when the job is subsequently restarted. This
      mechanism allows the job to pause temporarily.</para>

      <para>On the other hand, the "end" tag will stop the job but does not
      allow for a "to" attribute. The "status" attribute is optional. It will
      determine the exit status of the step if the flow ends at that location.
      The only legal values for the "status" are "COMPLETED", "FAILED", and
      "STOPPED". If no status is specified, then the default is
      "COMPLETED".</para>

      <para><programlisting>
  &lt;step name="step1"&gt;
    &lt;stop on="COMPLETED" to="step2"/&gt;
  &lt;/step&gt;
  &lt;step name="step2"&gt;
    &lt;next on="FOO" to="step3"/&gt;
    &lt;end on="*" status="FAILED"/&gt;
  &lt;/step&gt;
  &lt;step name="step3" /&gt;

</programlisting></para>
    </section>

    <section>
      <title>Programmatic flow decisions</title>

      <para>In some situations, more information than the exit status may be
      required to decide which step to execute next. In this case, a
      <classname>JobExecutionDecider</classname> can be used to assist in the
      decision.</para>

      <para><programlisting>
  public class MyDecider implements JobExecutionDecider {

    public String decide(JobExecution jobExecution, StepExecution stepExecution) {
      if (someCondition) {
        return "FAILED";
      }
      else {
        return "COMPLETED";
      }
    }

  }

</programlisting></para>

      <para>In the job configuration, a "decision" tag will specify the
      decider to use as well as all of the transitions.</para>

      <para><programlisting>
  &lt;job id="job"&gt;
    &lt;step name="step1" next="decision" /&gt;
    
    &lt;decision id="skipCheckingDecision" decider="decider"&gt;
      &lt;next on="FAILED" to="step2" /&gt;
      &lt;next on="COMPLETED" to="step3" /&gt;
    &lt;/step&gt;

    &lt;step name="step2" next="step3"/&gt;
    &lt;step name="step3" /&gt;
  &lt;/job&gt;

  &lt;bean id="decider" class="com.MyDecider"/&gt;

</programlisting></para>
    </section>

    <section>
      <title>Creating File Names at Runtime</title>

      <para>Both the XML and Flat File examples above use the Spring
      <classname>Resource</classname> abstraction to obtain the file to read
      or write from. This works because <classname>Resource</classname> has a
      <markup>getFile</markup> method, that returns a
      <classname>java.io.File</classname>. Both XML and Flat File resources
      can be configured using standard Spring constructs:</para>

      <programlisting>  &lt;bean id="flatFileItemReader"
        class="org.springframework.batch.item.file.FlatFileItemReader"&gt;
    &lt;property name="resource"
                     value="file://outputs/20070122.testStream.CustomerReportStep.TEMP.txt" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>The above <classname>Resource</classname> will load the file from
      the file system, at the location specificied. Note that absolute
      locations have to start with a double slash ("//"). In most spring
      applications, this solution is good enough because the names of these
      are known at compile time. However, in batch scenarios, the file name
      may need to be determined at runtime as a parameter to the job. This
      could be solved using '-D' parameters, i.e. a system property:</para>

      <programlisting>&lt;bean id="flatFileItemReader"
        class="org.springframework.batch.item.file.FlatFileItemReader"&gt;
    &lt;property name="resource" value="${input.file.name}" /&gt;
&lt;/bean&gt;</programlisting>

      <para>All that would be required for this solution to work would be a
      system argument (-Dinput.file.name="file://file.txt"). (Note that
      although a <classname>PropertyPlaceholderConfigurer</classname> can be
      used here, it is not necessary if the system property is always set
      because the <classname>ResourceEditor</classname> in Spring already
      filters and does placeholder replacement on system properties.)</para>

      <para>Often in a batch setting it is preferable to parameterize the file
      name in the <classname>JobParameters</classname> of the job, instead of
      through system properties, and access them that way. To allow for this,
      Spring Batch provides the
      <classname>StepExecutionResourceProxy</classname>. The proxy can use
      either job name, step name, or any values from the
      <classname>JobParameters</classname>, by surrounding them with %:</para>

      <programlisting>  &lt;bean id="inputFile"
        class="org.springframework.batch.core.resource.StepExecutionResourceProxy" /&gt;
    &lt;property name="filePattern" value="//%JOB_NAME%/%STEP_NAME%/%file.name%" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>Assuming a job name of 'fooJob', and a step name of 'fooStep', and
      the key-value pair of 'file.name="fileName.txt"' is in the
      <classname>JobParameters</classname> the job is started with, the
      following filename will be passed as the
      <classname>Resource</classname>:
      "<filename>//fooJob/fooStep/fileName.txt</filename>". It should be noted
      that in order for the proxy to have access to the
      <classname>StepExecution</classname>, it must be registered as a
      <classname>StepListener</classname>:</para>

      <programlisting>  &lt;bean id="fooStep" parent="abstractStep"
    p:itemReader-ref="itemReader"
    p:itemWriter-ref="itemWriter"&gt;
    &lt;property name="listeners" ref="inputFile" /&gt;
  &lt;/bean&gt;</programlisting>

      <para>The <classname>StepListener</classname> interface will be
      discussed in more detail in Chapter 4. For now, it is sufficient to know
      that the proxy must be registered.</para>
    </section>
  </section>
</chapter>